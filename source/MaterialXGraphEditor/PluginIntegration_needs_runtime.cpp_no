//
// Copyright Contributors to the MaterialX Project
// SPDX-License-Identifier: Apache-2.0
//

#include <pybind11/embed.h>
#include <filesystem>
#include <MaterialXRender/PluginManager.h>

namespace py = pybind11;
namespace fs = std::filesystem;

void load_python_plugins(const std::string& plugin_dir) {
    static std::unique_ptr<py::scoped_interpreter> guard;
    if (!Py_IsInitialized()) {
        guard = std::make_unique<py::scoped_interpreter>();
    }
    
    auto sys = py::module_::import("sys");
    sys.attr("path").attr("append")(plugin_dir);
    
    // Discover plugins
    for (const auto& entry : fs::directory_iterator(plugin_dir)) {
        if (entry.is_directory()) continue;
        
        if (entry.path().extension() == ".py") {
            std::string module_name = entry.path().stem().string();
            
            try {
                py::module_ mod = py::module_::import(module_name.c_str());
                
                // Find plugin classes
                py::dict dict = mod.attr("__dict__").cast<py::dict>();
                for (auto& kv : dict) {
                    py::handle value = kv.second;
                    if (py::isinstance<py::type>(value)) {
                        py::type cls = value.cast<py::type>();
                        // Check if it inherits from IPlugin
                        if (py::hasattr(cls, "__bases__")) {
                            for (auto base : cls.attr("__bases__")) {
                                if (py::hasattr(base, "__name__") && 
                                    base.attr("__name__").cast<std::string>() == "IPlugin") {
                                    // Instantiate and register
                                    auto instance = cls();
                                    auto bridge = py::module_::import("plugin_bridge");
                                    bridge.attr("register_plugin")(instance);
                                }
                            }
                        }
                    }
                }
            } catch (const py::error_already_set& /*e*/) {
                
                // Handle error
            }
        }
    }
}